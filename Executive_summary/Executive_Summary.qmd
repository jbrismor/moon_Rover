---
title: "Lunar Rover"
format:
  html:
    embed-resources: true
    code-fold: true
    toc: true
---

# Statement of problem

This project aims to be the first step of many more to follow on simulating and automating a lunar rover with the goal of collecting desired resources in a save and efficient manner.

##  General environment description

### Spatial Mesh: 

Consider an rectilinear spatial environment defined on a 2D grid, i.e. a grid-world.

Assume the physical dimension of the grid-size is defined by user-specified simulation parameters $Lx$ and $Ly$ which is partitions into $Nx$ and $Ny$ cells.

For simplicity, assume the grid-size is square, i.e. $Lx=Ly=35$ and $Nx=Ny=35$, pretending each cell is 1km by 1km.

* `Simulation parameters`:
  * $Lx$ : Length of the grid in the x-direction
  * $Ly$ : Length of the grid in the y-direction
  * $Nx$ : Number of cells in the x-direction
  * $Ny$ : Number of cells in the y-direction

Alternatively, the user could specify the size of a single cell, $dx=dy=1 ,meter$, and the number of cells in each dimension, $Nx=Lx/dx$, $Ny=Ly/dy$.

### Spatial information: 

We describe the geographical environment as a collection of $m$ spatial functions, $f_i(x, y)$ for $i = 1, 2, dots, m$, representing a set of $m$ scalar fields defined on the grid.

These functions represent various spatial attributes of interests, such as the probability distribution of water $p_w(x,y)$ or other resources, elevation or height encoding terrain topology $h(x,y)$, the depth of the lunar regolith $d(x,y)$, intensity of solar radiation $I(x,y)$, ... etc. An arbitrary number of such functions can be added as needed to address specific simulation requirements.

Note, these functions can also be modulated by adding a small random noise distributions $N_i(x,y)$ to the values of the functions, i.e. $f_i(x,y)=f_i(x,y)+N_i(x,y)$. Where the noise is re-set for each episode to inject randomness into the environment. 

In practice, these functions are represented as a set of $m$ matrices matching the dimensions of the grid-world, with each matrix containing values for the corresponding scalar field (e.g., heat maps or intensity maps).

These functions may be empirical measurements interpolated onto the grid from real-world data, or hypothetical continuous functions simulating a contrived model of the lunar surface. They are assumed constant within each grid cell. As the number of grid cells approaches infinity, these functions approximate the respective continuous fields; however, in practice, we adhere to a discrete, coarse-grained approximation.

### Boundary conditions:

We will assume fixed boundary conditions, i.e. the rover cannot move outside the grid-world and will bounce off the edges, if it attempts to exit.

### Time:

Each time step as of right now takes 24hours in Earth (as it will equal to one kilometer of movement). This can later be adjusted.

**Daylight cycle**: In this simulation, we will also include the normal fluctuations of light in the moon, rounding up to 30 days for a
full cycle. This will affect the battery charge.

### Sunlight:

The sunlight intensity is calculated throughout a lunar day-night cycle, and addapting the intensity of the sunlight on a dimensionless scale between 0 and 1 through a sinusoidal equation:
$$
sunlight = 0.5 * (1 + \sin(2 \times \pi \times (time\_fraction - 0.25))) \times height\_factor
$$ {#eq-sunlight}

### Surface Elevation:

Right now, due to our size, the levation has been created with a gaussian noise and smoothed out using a gaussian filter. Then, two peaks have been added to simulate a cliff and a crater.

### Lunar Dust:

The Lunar Dust adds stochasticity to the problem. First, it creates a base noise level for each cell in the grid through Python’s `noise` package. We used a Gaussian filter to smooth out the edges of the dust patches to avoid extreme differences in height. The values are then normalized on a scale of 0 to 1 meters and inverted such that lower areas (bottoms of cliffs, bottoms of craters) receive higher dust accumulation (this is also dependent on a dust_height_correlation parameter). The final dust map for the environment is calculated by this equation:
$$
\begin{aligned}
\text{final\_dust} = &\ (\text{dust\_height\_correlation} \times \text{height\_influence}) \\
&+ ((1 - \text{dust\_height\_correlation}) \times \text{dust\_map})
\end{aligned}
$$ {#eq-dust}

### Resources:

The goal of the rover is to find the desired resources (called gold and water for simplicity). In both resource scenarios, the rover does not initially know where any of the resources are located. 

For water, the probability distribution is of Gaussian nature, where the center of these water pools are randomized per episode. For every water resource, the Gaussian distribution is shaped through a covariance matrix, controlling both its spread and orientation. Additionally, to better simulate the unknown, we added a noise scale to the Gaussian values as means of providing randomness to the resource pools. To finalize the probability map, values under 0.15 are zeroed out and re-normalized to target potential resource regions of the map. We also clear out resource probabilities in the landing zone (center of the grid).

Gold, on the other hand, can be found in vein-like shapes across the environment. These veins are calculated by randomizing a starting location and direction of growth and mapping the resource in the specified direction with conditions to ensure a minimum resource amount and length. After calculating this probability map, the rest of the process mirrors that of the water calculation. Then ground truth is calculated utilizing the probability map, adding noise and thresholding, and converting to binary values.

### Rover attributes:

#### Battery:

The rover contains two batteries, the same size as the Apollo Lunar Roving Vehicle (LRV) at a capacity of 29,300 Wh each, making it a total of 58,600 Wh.

#### Solar pannels:

**Input**:

The rover has three solarpanels (like Apollo LRV) convert sunlight into Wh units, where the maximum amount of energy produced in a day with maximum sunlight is 6,532.8 Wh. The Input is calculated as follows:

$$
\text{Daily Output} = 272.2 \times 24 \times \text{num\_solar\_panels}
$$ {#eq-daily-energy}

$$
\begin{align}
\text{Energy Generated} &= \text{Daily Output} \times \text{Sunlight Intensity} 
\end{align}
$$ {#eq-generated_en}

**Output**:

The energy used follows the following rules:

- For every time step the rover uses a base consumption of 1,200 Wh for its systems and connectivity.
- For any action that is not staying still, the rover consumes 13,890 Wh per kilometer Wikipedia.
- If the rover chooses to gather a resource, it will automatically consume an additional 20,000 Wh.

Thus, the energy used is calculated as follows:

$$
\begin{align}
\text{Dust Factor} &= 1 + (\text{Dust Level} \times 0.5)
\end{align}
$$ {#eq-dust-factor}

$$
\begin{align}
\text{Height Factor} &= 0.5 + \frac{100}{\text{Height Difference}} 
\end{align}
$$ {#eq-height-factor}

$$
\begin{align}
\text{Movement Energy} &= 13,890 \times \text{Dust Factor} \times \text{Height Factor} 
\end{align}
$$ {#eq-movement}

$$
\begin{align}
\text{Next Battery Level} &= \text{Current Battery Level} + \nonumber \\ 
& \text{Energy Generated} - \text{Energy Consumed} 
\end{align}
$$ {#eq-bat}

### Terminal states:

There are three terminal states in the simulation:

- Crash: The change in height from one cell to the next is higher than 25 meters.
- Stuck: Using a sigmoid probability function, the rover’s chance of getting stuck increases dramatically as dust depth approaches 0.25 meters, reaching a maximum 50% probability at 0.5 meters depth.
  - Once stuck, the rover continues consuming energy while unable to move. If the rover remains stuck for 5 consecutive days, the mission is considered a failure and reaches a terminal state.
- Random death: The rover’s probability of failing increases each day, reaching a maximum probability of 5% at the end of the episode (day 365).

### Actions:

The following actions are available to the rover:

- Stay still
- Move up
- Move down
- Move left
- Move right
- Gather resource

### Rewards:

The reward structure is as follows:

::: {#table-rewards}
| **Scenario**                  | **Reward/Penalty**           | **Explanation**                                                                   |
|-------------------------------|------------------------------|-----------------------------------------------------------------------------------|
| Base Time Penalty             | \(-1\)                      | Penalizes every time step to encourage efficiency.                                |
| Monthly Survival Bonus        | \(+100\)                    | Reward for surviving another month.                                              |
| Stuck State Daily Penalty     | \(-30\)                     | Penalty for being unable to move.                                                |
| Terminal Stuck Penalty        | \(-100,000\)                | Ending penalty if stuck for 5 consecutive days.                                  |
| Crash Penalty                 | \(-100,000\)                | Penalty if the agent crashes due to height changes.                              |
| Gathering Water (Base)        | \(+200 \times \text{decay}\)| Reward for collecting water, reduced by decay for repeated gathers.              |
| Gathering Gold (Base)         | \(+300 \times \text{decay}\)| Reward for collecting gold, reduced by decay for repeated gathers.               |
| Low Battery Penalty           | \(-20\)                     | Penalty if the battery level drops below \(20\%\).                               |
| Overcharged Battery Penalty   | \(-15\)                     | Penalty if the battery exceeds \(95\%\).                                         |
:::