---
title: "Lunar Rover"
format:
  html:
    embed-resources: true
    code-fold: true
    toc: true
---

# Statement of problem

This project aims to be the first step of many more to follow on simulating and automating a lunar rover with the goal of collecting desired resources in a save and efficient manner.

##  General environment description

### Spatial Mesh: 

Consider an rectilinear spatial environment defined on a 2D grid, i.e. a grid-world.

Assume the physical dimension of the grid-size is defined by user-specified simulation parameters $Lx$ and $Ly$ which is partitions into $Nx$ and $Ny$ cells.

For simplicity, assume the grid-size is square, i.e. $Lx=Ly$ and $Nx=Ny$. 

For debugging and prototyping, we will set $Lx=Ly=25$ meters, and $Nx=Ny=25$.

* `Simulation parameters`:
  * $Lx$ : Length of the grid in the x-direction
  * $Ly$ : Length of the grid in the y-direction
  * $Nx$ : Number of cells in the x-direction
  * $Ny$ : Number of cells in the y-direction

Alternatively, the user could specify the size of a single cell, $dx=dy=1 ,meter$, and the number of cells in each dimension, $Nx=Lx/dx$, $Ny=Ly/dy$.

### Spatial information: 

We describe the geographical environment as a collection of $m$ spatial functions, $f_i(x, y)$ for $i = 1, 2, dots, m$, representing a set of $m$ scalar fields defined on the grid.

These functions represent various spatial attributes of interests, such as the probability distribution of water $p_w(x,y)$ or other resources, elevation or height encoding terrain topology $h(x,y)$, the depth of the lunar regolith $d(x,y)$, intensity of solar radiation $I(x,y)$, ... etc. An arbitrary number of such functions can be added as needed to address specific simulation requirements.

Note, these functions can also be modulated by adding a small random noise distributions $N_i(x,y)$ to the values of the functions, i.e. $f_i(x,y)=f_i(x,y)+N_i(x,y)$. Where the noise is re-set for each episode to inject randomness into the environment. 

In practice, these functions are represented as a set of $m$ matrices matching the dimensions of the grid-world, with each matrix containing values for the corresponding scalar field (e.g., heat maps or intensity maps).

These functions may be empirical measurements interpolated onto the grid from real-world data, or hypothetical continuous functions simulating a contrived model of the lunar surface. They are assumed constant within each grid cell. As the number of grid cells approaches infinity, these functions approximate the respective continuous fields; however, in practice, we adhere to a discrete, coarse-grained approximation.

### Boundary conditions:

We will assume fixed boundary conditions, i.e. the rover cannot move outside the grid-world and will bounce off the edges, if it attempts to exit.

The model could also be extended to include periodic boundary conditions, i.e. the rover will wrap around to the opposite side of the grid-world, if it attempts to exit.

However, for simplicity, we will adhere to fixed boundary conditions.

### Time:

The simulation time $t_i=Delta t times i$ is discrete, and defined by a time-step size $Delta t$, which is the amount of time that elapses between each simulation step. 

The episode will run for a fixed number of time-steps, $T$, which is a user-specified parameter. This parameter can be chosen to represent a realistic anticipated lifetime of the rover, e.g. 2 years. However, the episode can also terminate early if the rover becomes inoperable.

The total number of steps is therefore $N_t=frac{T}{Delta t}$.

The rover transverses the grid-world as it moves through the environment, this path is described by $mathbf r_i=(x_i,y_i)=(x(t_i), y(t_i))$ for $t=0, 1, 2, dots, T$.

The rover attempts to take one step $mathbf r_i=Delta x, 0$ or $mathbf Delta r_i=(0, Delta y)$ per time-step. 

Therefore $Delta t$ can be chosen based on a realistic rover velocity. 

For example, assuming a slow rover velocity, with a speed of 1 meter/hr, we could assume a time-step of 1 hour (i.e. 1 cell per time-step (per hour)). If we simulation for $T=2$ years, we would need $N_t=17532$ steps.

**Daylight cycle**: In this simulation, we will also include the normal fluctuations of light in a day, which will affect the battery charge and maybe the rover's sensors.

### Rover attributes:

* Static attributes
  * Mass (kg)
  * Battery capacity (kw-Hr)
  * Baseline energy consumption rate (Watts)
* Dynamic attributes ($t_i$)
  * Current battery level (kw-Hr)
  * Current position $mathbf r_i=(x(t_i), y(t_i))$
  * Current height: $h_i=h(x(t_i), y(t_i))$

### Energy usage:

At each time-step, the rover consumes energy to move, and to operate its sensors and other components.

It also absorbs energy from the sun, which is a function of the solar lumination at the current location $I(x(t_i), y(t_i))$.

We assume the following simplistic energy consumption model:

$$Delta E_i=Delta E_{in}(I_i)+Delta E_{out}(Delta h_{i-1})$$

Where $Delta E_{in}$ is the energy absorbed from the sun, and $Delta E_{out}$ is the energy consumed to move the rover.

This model can easily be parameterized based on realistic consumptions and absorption rates which can be estimated based on the size and efficiency of the rovers solar panels, and its average energy consumption per unit distance.

The battery level is incremented based on $Delta E_i$.

Each time step, the battery level is updated based from the amount of energy consumed, and the amount of energy absorbed from the sun. The first is calculated based on the distance moved, the change in height, and the amount of lunar dust (noise). The second is calculated based on the intensity of the sun at that time of the day.

## Initial environment

For prototyping and debugging, we will use a simple environment described as follower 



$f_1(x,y)$ = water distribution (probability distribution for water)

$f_2(x,y)$ = gold distribution (probability distribution for gold)



For simplicity assume these are just 2D Gaussian distributions as follows

$$
f(x, y)=frac{1}{2 pi sigma_X sigma_Y sqrt{1-rho^2}} mathrm{e}^{-frac{1}{2left(1-rho^2right)}left[left(frac{x-mu_X}{sigma_X}right)^2-2 rholeft(frac{x-mu_X}{sigma_X}right)left(frac{y-mu_Y}{sigma_Y}right)+left(frac{y-mu_Y}{sigma_Y}right)^2right]}
$$ 

For the parameters $boldsymbol{mu}$ and $mathbf{Sigma}$

$$
boldsymbol{mu}=binom{mu_X}{mu_Y}, quad mathbf{Sigma}=left(begin{array}{cc}
sigma_X^2 & rho sigma_X sigma_Y 
rho sigma_X sigma_Y & sigma_Y^2
end{array}right)
$$

For the simulation parameters use

$f_1 rightarrow boldsymbol{mu}=(20,20), sigma_X=1, sigma_Y=1, rho=0.25$

$f_2 rightarrow boldsymbol{mu}=(10,10), sigma_X=1, sigma_Y=1, rho=-0.25$

From these, you can create a matrix (heat-map), with the value of these functions sampled at the lower left corner of the grid. For example cell (0,0) $rightarrow$ x=0,y=0

The state-reward is created based on a weighted sum of these

$R(x,y)= A f_1(x,y) + (1-A) f_2(x,y)$ 

Where $A$ is a user-parameter that defines the explorers primary interests, for example (A)=1 would mean they only care about water and not gold. For consistancy, Please use `A=0.75`

### Height:

We assume the height is a bi-variate normal distribution (working on this by Eric)

```{python, eval=FALSE}
#| eval: false

## Plot of the height distribution

import matplotlib.pyplot as plt

import numpy as np

from scipy.stats import multivariate_normal

dx=1 #meter

dy=1 #meter

Nx=25

Ny=25

Lx=Nx*dx

Ly=Ny*dy

ux=Lx/2

uy=Ly/2

sx=Lx/6

sy=Ly/6

rho=0.25

x = np.linspace(0, Lx, Nx)

y = np.linspace(0, Ly, Ny)

X, Y = np.meshgrid(x, y)

def height_distribution(ux, uy, sx, sy, rho):
    return np.exp(-0.5*((X-ux)/sx)**2 - 0.5*((Y-uy)/sy)**2 - rho*((X-ux)/sx)*((Y-uy)/sy))

# surface plot of the height distribution

import matplotlib.pyplot as plt

from mpl_toolkits.mplot3d import Axes3D

import numpy as np

H=height_distribution(ux, uy, sx, sy, rho)

# Create a 3D plot
fig = plt.figure()

ax = fig.add_subplot(111, projection='3d')

surface = ax.plot_surface(X, Y, H, cmap='viridis', edgecolor='none')

# Add color bar and labels
fig.colorbar(surface, ax=ax, shrink=0.5, aspect=5, label="f(x, y)")

ax.set_title("3D Surface Plot of height function h(x, y)")

ax.set_xlabel("X-axis")

ax.set_ylabel("Y-axis")

ax.set_zlabel("Height (m)")

# Show plot

plt.show()
```

## Action space

The action space of the rover is defined by a set of actions, each action is a vector of length 2, representing the change in position of the rover in the x and y directions.

The action space is defined as follows:

$$
\mathcal{A} = \left\{
\begin{array}{cc}
(1,0) & \text{Move right} \\
(-1,0) & \text{Move left} \\
(0,1) & \text{Move up} \\
(0,-1) & \text{Move down} \\
(0,0) & \text{Stay put or gather}
\end{array}
\right\}
$$


The rover can only move to a new cell if it is not an obstacle (e.g. a wall or a very steep hill), and if it is within the grid-world.

## Rewards

The rewards of this problem are set in a way to penalize the rover for taking longer paths and spending a lot of energy but encouraging it to find the desired resources. The reward structure is defined as follows:

- Each time step the rover takes, it will receive a negative reward of -1.
- If the rover is in a resource cell, it will receive a reward based on our function $R(x,y)$.
- If the rover has a battery level under 20%, it will receive a negative reward of -10.
- The rover will receive a reward based on the battery change in each step.
- The rover will receive a positive reward if it gathers in a resource (prob as heatmap), and negative if it gathers outside a resource.

# Randomness 

In order to make the problem well suited for Reinforcement Learning, we need to add randomness to the environment.

We will do this by considering the following real world stochastic possibilities:

In simulation, these events will be randomly sampled, at each time-step. This will be done with a randomizer algorithm that witll change continuously the amount of lunar dust in the environment. If the lunar dust stays under a certain probability (e.g. 0.3), then it doesn't affect the rover. If it goes above that probability, then the rover will have a certain probability of getting stuck and will influence the energy consumption of the rover.

**Note**: Technically the probabilities need to be treated as rates, i.e. the probability of the event per time-step, otherwise the events will occur too frequently in simulation, and need to treated accordingly, i.e. they need to be multiplied by the time-step size, 


## Traction issues

### Getting stuck  

* We assume that the probability of getting stuck is a function of the depth $d$ of the lunar regolith. Where the depth of the lunar regolith is a function of the location in the grid, denoted $d(x, y)$.

* We model the probability of getting stuck as a sigmoid function of the depth of the lunar regolith.
  * The $w$ parameter is the width of the sigmoid function.
  * The $xo$ parameter is the location of the center of the sigmoid function.
  * These are simulation parameters, that are set by the user, we set them to $w=0.05$ meters and $xo=0.25$ meters.

$$p_s(x, y)=p_{stuck}(x, y) = frac{1}{1 + e^{-(d(x, y) - xo)/w}}$$

* We assume the depth takes on values between 0 and 1 meters.

The following plot shows the probability of getting stuck as a function of the depth of the lunar regolith.

```{python, eval=FALSE}
#| eval: false
## Plot of the probablity of getting stuck as a function of depth.

import matplotlib.pyplot as plt
import numpy as np


# units of meters

- w=0.05
- xo=0.25
- x = np.linspace(0, 0.5, 100)
- y = 1 / (1 + np.exp(-(x - xo) / w))

# label the axes

plt.plot(x, y)

plt.xlabel('Depth (m)')

plt.ylabel('Probability of getting stuck')

plt.show()

# here we show the same plot but in ft rather than meters.

plt.plot(x*3.28084, y)

plt.xlabel('Depth (ft)')

plt.ylabel('Probability of getting stuck')

plt.show()
```

### Getting un-stuck

If stuck, the action-set is constrained, it will still use energy in an attempt to get out, unless it becomes dormant to charge its battery. allowing it to no longer move, the probability of getting "un-stuck" is modeled by $p_{unstuck}(x, y|stuck) = 1-p_{stuck}(x, y)$. For example, if the rover is stuck, time-steps will still continue to iterate, we will keep sampling random numbers until it gets a number less than $1-p_s(x, y)$.

```{python, eval=FALSE}
#| eval: false
# here we show the same plot but in ft rather than meters.

plt.plot(x*3.28084, y,"-")
plt.plot(x*3.28084, 1-y,"-")
plt.plot(x[-1]+1.5, 0,"-")

plt.xlabel('Depth (ft)')
plt.ylabel('Probability of getting stuck')

# legend
plt.legend(['P(d|not_stuck) getting stuck', 'P(d|stuck): un-stuck'],loc='best')

plt.show()
```

`Note:` We could make its probability of getting un-stuck also a function of its energy level (i.e. it is harder to get un-stuck with lower batteries). i.e. $p_{unstuck}(d,e|stuck)$ where $d$ is the depth of the lunar regolith and $e$ is the current energy level of the rover.

## Crashing

* In certain locations, the rover may fall down a hill, or a cliff, and become inoperable, this will result in a significant negative reward, and terminate the episode. 

* We model the probability of crashing as a function of the slope of the terrain associated with the last step, this step will result in some change in height, denoted $Delta h$, the probability of crashing is $p_{crash}(Delta h)$. This can be modeled either as a sigmoid function (recommended), or a linear function (e.g. $p_{crash}(Delta h) = alphaDelta h$).

## Component failure: 

Logically the rover will eventually fail, for example some component will break, causing the rover to become inoperable, which will terminate the episode. We assume the probability of failure will increase with the age of the rover (i.e. simulation time $t$), where failure will eventually become inevitable.

We also model this probability as a sigmoid function, but as a function of the simulation time $t$.

$$p_f(t) = frac{1}{1 + e^{-(t - tau)/l}}$$

Where $t$, $tau$, and $l$ are all in units of years. The parameter $tau$ can be interpreted as a half-life, i.e. the age at which the probability of failure is 50%, and $l$ is the size of the temporal window over which failure becomes likely.

```{python, eval=FALSE}
#| eval: false
# units of meters

tau=2
l=0.25
t = np.linspace(0, tau+6*l, 100)
pf = 1 / (1 + np.exp(-(t - tau) / l))

# label the axes
plt.plot(t, pf)
plt.xlabel('Simulation time (years)')
plt.ylabel('Probability of component failure')
plt.show()
```